# Test scenarios for fastapi-router-py skill evaluation
# Each scenario tests a specific FastAPI router pattern against acceptance criteria

config:
  model: gpt-4
  max_tokens: 2000
  temperature: 0.3

scenarios:
  # Basic CRUD Router
  - name: basic_crud_router
    prompt: |
      Create a FastAPI router for managing "projects" with full CRUD operations.
      Include GET (list and single), POST (create), PATCH (update), and DELETE endpoints.
      Use proper status codes, response models, and async/await patterns.
      Include pagination with limit and offset query parameters.
    expected_patterns:
      - "APIRouter"
      - "prefix="
      - "response_model="
      - "status.HTTP_201_CREATED"
      - "status.HTTP_204_NO_CONTENT"
      - "async def"
      - "Query"
      - "limit"
      - "offset"
    forbidden_patterns:
      - "(?<!async )def list_projects"
      - "(?<!async )def create_project"
      - "@router.post.*response_model=list"
      - "\\.get\\(.*list"
    tags:
      - basic
      - crud
      - pagination
    mock_response: |
      from typing import Optional
      from fastapi import APIRouter, Depends, HTTPException, Query, status
      
      from app.models.project import ProjectResponse, ProjectCreate, ProjectUpdate
      from app.services.project_service import ProjectService
      
      router = APIRouter(prefix="/api", tags=["projects"])
      
      def get_service() -> ProjectService:
          """Dependency to get service instance."""
          return ProjectService()
      
      @router.get("/projects", response_model=list[ProjectResponse])
      async def list_projects(
          limit: int = Query(default=50, ge=1, le=100),
          offset: int = Query(default=0, ge=0),
          service: ProjectService = Depends(get_service),
      ) -> list[ProjectResponse]:
          """List all projects with pagination."""
          return await service.list_projects(limit=limit, offset=offset)
      
      @router.get("/projects/{project_id}", response_model=ProjectResponse)
      async def get_project(
          project_id: str,
          service: ProjectService = Depends(get_service),
      ) -> ProjectResponse:
          """Get a specific project by ID."""
          result = await service.get_project_by_id(project_id)
          if result is None:
              raise HTTPException(
                  status_code=status.HTTP_404_NOT_FOUND,
                  detail="Project not found",
              )
          return result
      
      @router.post(
          "/projects",
          response_model=ProjectResponse,
          status_code=status.HTTP_201_CREATED,
      )
      async def create_project(
          data: ProjectCreate,
          service: ProjectService = Depends(get_service),
      ) -> ProjectResponse:
          """Create a new project."""
          return await service.create_project(data)
      
      @router.patch("/projects/{project_id}", response_model=ProjectResponse)
      async def update_project(
          project_id: str,
          data: ProjectUpdate,
          service: ProjectService = Depends(get_service),
      ) -> ProjectResponse:
          """Update an existing project."""
          existing = await service.get_project_by_id(project_id)
          if existing is None:
              raise HTTPException(
                  status_code=status.HTTP_404_NOT_FOUND,
                  detail="Project not found",
              )
          return await service.update_project(project_id, data)
      
      @router.delete(
          "/projects/{project_id}",
          status_code=status.HTTP_204_NO_CONTENT,
      )
      async def delete_project(
          project_id: str,
          service: ProjectService = Depends(get_service),
      ) -> None:
          """Delete a project."""
          existing = await service.get_project_by_id(project_id)
          if existing is None:
              raise HTTPException(
                  status_code=status.HTTP_404_NOT_FOUND,
                  detail="Project not found",
              )
          await service.delete_project(project_id)

  # Router with Authentication
  - name: router_with_authentication
    prompt: |
      Create a FastAPI router for "tasks" where:
      - GET endpoints (list, single) allow optional authentication
      - POST, PATCH, DELETE endpoints require authentication
      - Use get_current_user for optional and get_current_user_required for required auth
      Include proper type hints and HTTPException for unauthorized access.
    expected_patterns:
      - "get_current_user"
      - "get_current_user_required"
      - "Optional\\[User\\]"
      - "User = Depends"
      - "HTTPException"
      - "HTTP_401_UNAUTHORIZED"
      - "HTTP_403_FORBIDDEN"
    forbidden_patterns:
      - "current_user: str"  # Should be User type
      - "current_user: Optional[^\\[]"  # Should have full type like Optional[User]
      - "get_current_user_required.*Optional"  # Can't be both required and optional
    tags:
      - authentication
      - security
    mock_response: |
      from typing import Optional
      from fastapi import APIRouter, Depends, HTTPException, status
      
      from app.auth.jwt import get_current_user, get_current_user_required
      from app.models.user import User
      from app.models.task import TaskResponse, TaskCreate, TaskUpdate
      from app.services.task_service import TaskService
      
      router = APIRouter(prefix="/api", tags=["tasks"])
      
      def get_service() -> TaskService:
          """Dependency to get service instance."""
          return TaskService()
      
      @router.get("/tasks", response_model=list[TaskResponse])
      async def list_tasks(
          current_user: Optional[User] = Depends(get_current_user),
          service: TaskService = Depends(get_service),
      ) -> list[TaskResponse]:
          """List tasks. Authentication optional."""
          user_id = current_user.id if current_user else None
          return await service.list_tasks(user_id=user_id)
      
      @router.post(
          "/tasks",
          response_model=TaskResponse,
          status_code=status.HTTP_201_CREATED,
      )
      async def create_task(
          data: TaskCreate,
          current_user: User = Depends(get_current_user_required),
          service: TaskService = Depends(get_service),
      ) -> TaskResponse:
          """Create a new task. Authentication required."""
          return await service.create_task(data, owner_id=current_user.id)
      
      @router.patch("/tasks/{task_id}", response_model=TaskResponse)
      async def update_task(
          task_id: str,
          data: TaskUpdate,
          current_user: User = Depends(get_current_user_required),
          service: TaskService = Depends(get_service),
      ) -> TaskResponse:
          """Update task. Authentication required."""
          existing = await service.get_task_by_id(task_id)
          if existing is None:
              raise HTTPException(
                  status_code=status.HTTP_404_NOT_FOUND,
                  detail="Task not found",
              )
          if existing.owner_id != current_user.id:
              raise HTTPException(
                  status_code=status.HTTP_403_FORBIDDEN,
                  detail="Not authorized to update this task",
              )
          return await service.update_task(task_id, data)
      
      @router.delete(
          "/tasks/{task_id}",
          status_code=status.HTTP_204_NO_CONTENT,
      )
      async def delete_task(
          task_id: str,
          current_user: User = Depends(get_current_user_required),
          service: TaskService = Depends(get_service),
      ) -> None:
          """Delete task. Authentication required."""
          existing = await service.get_task_by_id(task_id)
          if existing is None:
              raise HTTPException(
                  status_code=status.HTTP_404_NOT_FOUND,
                  detail="Task not found",
              )
          if existing.owner_id != current_user.id:
              raise HTTPException(
                  status_code=status.HTTP_403_FORBIDDEN,
                  detail="Not authorized to delete this task",
              )
          await service.delete_task(task_id)

  # Response Models with Proper Typing
  - name: response_models_typing
    prompt: |
      Create a FastAPI router for "articles" where:
      - List endpoint returns list[ArticleResponse]
      - Single get endpoint returns ArticleResponse
      - Create endpoint returns ArticleResponse with 201 status
      - Delete endpoint returns 204 No Content (None)
      Define Pydantic models with Config.from_attributes for ORM compatibility.
    expected_patterns:
      - "response_model=list\\[ArticleResponse\\]"
      - "response_model=ArticleResponse"
      - "status_code=status.HTTP_201_CREATED"
      - "status_code=status.HTTP_204_NO_CONTENT"
      - "\\) -> list\\[ArticleResponse\\]"
      - "\\) -> ArticleResponse"
      - "\\) -> None"
    forbidden_patterns:
      - "response_model=dict"
      - "response_model=str"
      - "response_model=list[^\\[]"  # Should specify type: list[Model], not just list
      - "-> dict:"
      - "-> Any:"
    tags:
      - response-models
      - typing
    mock_response: |
      from fastapi import APIRouter, Depends, HTTPException, status
      from pydantic import BaseModel
      
      from app.models.article import ArticleResponse, ArticleCreate
      from app.services.article_service import ArticleService
      
      router = APIRouter(prefix="/api", tags=["articles"])
      
      def get_service() -> ArticleService:
          return ArticleService()
      
      @router.get("/articles", response_model=list[ArticleResponse])
      async def list_articles(
          service: ArticleService = Depends(get_service),
      ) -> list[ArticleResponse]:
          """List all articles."""
          return await service.list_articles()
      
      @router.get("/articles/{article_id}", response_model=ArticleResponse)
      async def get_article(
          article_id: str,
          service: ArticleService = Depends(get_service),
      ) -> ArticleResponse:
          """Get a single article."""
          article = await service.get_article_by_id(article_id)
          if article is None:
              raise HTTPException(
                  status_code=status.HTTP_404_NOT_FOUND,
                  detail="Article not found",
              )
          return article
      
      @router.post(
          "/articles",
          response_model=ArticleResponse,
          status_code=status.HTTP_201_CREATED,
      )
      async def create_article(
          data: ArticleCreate,
          service: ArticleService = Depends(get_service),
      ) -> ArticleResponse:
          """Create a new article."""
          return await service.create_article(data)
      
      @router.delete(
          "/articles/{article_id}",
          status_code=status.HTTP_204_NO_CONTENT,
      )
      async def delete_article(
          article_id: str,
          service: ArticleService = Depends(get_service),
      ) -> None:
          """Delete an article."""
          existing = await service.get_article_by_id(article_id)
          if existing is None:
              raise HTTPException(
                  status_code=status.HTTP_404_NOT_FOUND,
                  detail="Article not found",
              )
          await service.delete_article(article_id)

  # Query Parameter Validation
  - name: query_parameter_validation
    prompt: |
      Create a FastAPI router for "search" that accepts multiple query parameters:
      - q (required string search term, 1-200 chars)
      - limit (optional int, default 50, between 1-100)
      - offset (optional int, default 0, non-negative)
      - sort_by (optional string, one of: relevance, date, popularity)
      Use Query() for validation and descriptions. Include docstrings.
    expected_patterns:
      - "Query\\("
      - "min_length="
      - "max_length="
      - "ge="
      - "le="
      - "Query\\(default="
      - "description="
    forbidden_patterns:
      - "q: str"  # Should have Query validation
      - "limit: int = 50"  # Should have Query with constraints
      - "offset: int = 0"  # Should have Query with constraints
      - "Query\\(\\)"  # Query should have parameters
    tags:
      - validation
      - query-parameters
    mock_response: |
      from typing import Annotated, Optional
      from fastapi import APIRouter, Depends, Query, status
      
      from app.models.search import SearchResponse
      from app.services.search_service import SearchService
      
      router = APIRouter(prefix="/api", tags=["search"])
      
      def get_service() -> SearchService:
          return SearchService()
      
      @router.get("/search", response_model=list[SearchResponse])
      async def search(
          q: Annotated[str, Query(min_length=1, max_length=200, description="Search query")],
          limit: Annotated[int, Query(ge=1, le=100, description="Max results")] = 50,
          offset: Annotated[int, Query(ge=0, description="Results to skip")] = 0,
          sort_by: Annotated[Optional[str], Query(description="Sort by: relevance, date, popularity")] = "relevance",
          service: SearchService = Depends(get_service),
      ) -> list[SearchResponse]:
          """
          Search for items.
          
          - **q**: Search term (required, 1-200 characters)
          - **limit**: Maximum results to return (1-100, default 50)
          - **offset**: Number of results to skip (default 0)
          - **sort_by**: Sort results by relevance, date, or popularity
          """
          return await service.search(q=q, limit=limit, offset=offset, sort_by=sort_by)

  # Error Handling with HTTPException
  - name: error_handling_http_exception
    prompt: |
      Create a FastAPI router for "users" with comprehensive error handling:
      - 404 when user not found
      - 403 when user not authorized (e.g., trying to update someone else's profile)
      - 409 when email already exists (conflict)
      Use HTTPException with appropriate status codes and detail messages.
    expected_patterns:
      - "HTTPException"
      - "status.HTTP_404_NOT_FOUND"
      - "status.HTTP_403_FORBIDDEN"
      - "status.HTTP_409_CONFLICT"
      - "detail="
      - "if.*is None"
      - "if.*owner_id"
    forbidden_patterns:
      - "except"  # Should use HTTPException, not try/except
      - "return None"  # Should raise HTTPException instead
      - "raise Exception"  # Should use HTTPException
    tags:
      - error-handling
      - security
    mock_response: |
      from fastapi import APIRouter, Depends, HTTPException, status
      
      from app.models.user import UserResponse, UserUpdate
      from app.auth.jwt import get_current_user_required
      from app.models.user import User
      from app.services.user_service import UserService
      
      router = APIRouter(prefix="/api", tags=["users"])
      
      def get_service() -> UserService:
          return UserService()
      
      @router.get("/users/{user_id}", response_model=UserResponse)
      async def get_user(
          user_id: str,
          service: UserService = Depends(get_service),
      ) -> UserResponse:
          """Get a user by ID."""
          user = await service.get_user_by_id(user_id)
          if user is None:
              raise HTTPException(
                  status_code=status.HTTP_404_NOT_FOUND,
                  detail="User not found",
              )
          return user
      
      @router.patch("/users/{user_id}", response_model=UserResponse)
      async def update_user(
          user_id: str,
          data: UserUpdate,
          current_user: User = Depends(get_current_user_required),
          service: UserService = Depends(get_service),
      ) -> UserResponse:
          """Update user profile."""
          if user_id != current_user.id:
              raise HTTPException(
                  status_code=status.HTTP_403_FORBIDDEN,
                  detail="Not authorized to update this user",
              )
          
          existing = await service.get_user_by_id(user_id)
          if existing is None:
              raise HTTPException(
                  status_code=status.HTTP_404_NOT_FOUND,
                  detail="User not found",
              )
          
          if data.email and data.email != existing.email:
              existing_email = await service.get_user_by_email(data.email)
              if existing_email is not None:
                  raise HTTPException(
                      status_code=status.HTTP_409_CONFLICT,
                      detail="Email already exists",
                  )
          
          return await service.update_user(user_id, data)

  # Multiple Routers and Mounting
  - name: multiple_routers_mounting
    prompt: |
      Create two separate routers: one for "posts" and one for "comments".
      Each router should have basic CRUD operations.
      Show how they would be imported and mounted in a main.py file.
      Include proper prefixes (e.g., /api/posts, /api/comments).
    expected_patterns:
      - "APIRouter\\(prefix="
      - "tags="
      - "app.include_router"
      - "from.*import.*router"
      - "posts"
      - "comments"
    forbidden_patterns:
      - "include_router.*prefix.*prefix"  # Double prefix mounting
      - "APIRouter\\(\\)"  # Should have prefix
    tags:
      - routing
      - advanced
    mock_response: |
      # routers/posts.py
      from fastapi import APIRouter, Depends, HTTPException, status
      
      from app.models.post import PostResponse, PostCreate
      from app.services.post_service import PostService
      
      router = APIRouter(prefix="/api/posts", tags=["posts"])
      
      def get_service() -> PostService:
          return PostService()
      
      @router.get("", response_model=list[PostResponse])
      async def list_posts(service: PostService = Depends(get_service)) -> list[PostResponse]:
          """List all posts."""
          return await service.list_posts()
      
      @router.post(
          "",
          response_model=PostResponse,
          status_code=status.HTTP_201_CREATED,
      )
      async def create_post(
          data: PostCreate,
          service: PostService = Depends(get_service),
      ) -> PostResponse:
          """Create a new post."""
          return await service.create_post(data)
      
      # routers/comments.py
      from fastapi import APIRouter, Depends, HTTPException, status
      
      from app.models.comment import CommentResponse, CommentCreate
      from app.services.comment_service import CommentService
      
      router = APIRouter(prefix="/api/comments", tags=["comments"])
      
      def get_service() -> CommentService:
          return CommentService()
      
      @router.get("", response_model=list[CommentResponse])
      async def list_comments(service: CommentService = Depends(get_service)) -> list[CommentResponse]:
          """List all comments."""
          return await service.list_comments()
      
      @router.post(
          "",
          response_model=CommentResponse,
          status_code=status.HTTP_201_CREATED,
      )
      async def create_comment(
          data: CommentCreate,
          service: CommentService = Depends(get_service),
      ) -> CommentResponse:
          """Create a new comment."""
          return await service.create_comment(data)
      
      # main.py
      from fastapi import FastAPI
      from routers.posts import router as posts_router
      from routers.comments import router as comments_router
      
      app = FastAPI(title="My API")
      app.include_router(posts_router)
      app.include_router(comments_router)

  # Async Patterns with Service Injection
  - name: async_patterns_service_injection
    prompt: |
      Create a FastAPI router for "notifications" that demonstrates:
      - All endpoints use async def
      - Service is injected via Depends()
      - All service calls use await
      - Proper error handling with HTTPException
      Include at least GET, POST, and DELETE endpoints.
    expected_patterns:
      - "async def"
      - "await"
      - "Depends\\(get_service"
      - "NotificationService"
      - "HTTPException"
    forbidden_patterns:
      - "(?<!async )def list_notifications"  # Should be async
      - "(?<!await )service\\.get_notification"  # Should be await
      - "Depends\\(\\)"  # Should have function
      - "NotificationService\\(\\)"  # Should be via Depends
    tags:
      - async
      - service-injection
    mock_response: |
      from fastapi import APIRouter, Depends, HTTPException, status
      
      from app.models.notification import NotificationResponse, NotificationCreate
      from app.services.notification_service import NotificationService
      
      router = APIRouter(prefix="/api", tags=["notifications"])
      
      def get_service() -> NotificationService:
          """Dependency to get service instance."""
          return NotificationService()
      
      @router.get("/notifications", response_model=list[NotificationResponse])
      async def list_notifications(
          service: NotificationService = Depends(get_service),
      ) -> list[NotificationResponse]:
          """List all notifications."""
          return await service.list_notifications()
      
      @router.get("/notifications/{notification_id}", response_model=NotificationResponse)
      async def get_notification(
          notification_id: str,
          service: NotificationService = Depends(get_service),
      ) -> NotificationResponse:
          """Get a notification by ID."""
          notification = await service.get_notification_by_id(notification_id)
          if notification is None:
              raise HTTPException(
                  status_code=status.HTTP_404_NOT_FOUND,
                  detail="Notification not found",
              )
          return notification
      
      @router.post(
          "/notifications",
          response_model=NotificationResponse,
          status_code=status.HTTP_201_CREATED,
      )
      async def create_notification(
          data: NotificationCreate,
          service: NotificationService = Depends(get_service),
      ) -> NotificationResponse:
          """Create a new notification."""
          return await service.create_notification(data)
      
      @router.delete(
          "/notifications/{notification_id}",
          status_code=status.HTTP_204_NO_CONTENT,
      )
      async def delete_notification(
          notification_id: str,
          service: NotificationService = Depends(get_service),
      ) -> None:
          """Delete a notification."""
          existing = await service.get_notification_by_id(notification_id)
          if existing is None:
              raise HTTPException(
                  status_code=status.HTTP_404_NOT_FOUND,
                  detail="Notification not found",
              )
          await service.delete_notification(notification_id)

  # Complex Dependency Chain
  - name: complex_dependency_chain
    prompt: |
      Create a FastAPI router for "reports" that demonstrates:
      - Dependency functions that depend on other dependencies
      - Service injection through Depends()
      - Authentication dependency
      - Query parameters with validation
      - Include endpoints that use all dependencies together
    expected_patterns:
      - "Depends\\(get_service"
      - "Depends\\(get_current_user"
      - "Query\\("
      - "async def.*Depends"
      - "service.*=.*Depends"
      - "current_user.*=.*Depends"
    forbidden_patterns:
      - "service = ReportService\\(\\)"  # Should use Depends
      - "current_user: str"  # Should be User type
    tags:
      - dependencies
      - advanced
    mock_response: |
      from typing import Optional
      from fastapi import APIRouter, Depends, HTTPException, Query, status
      
      from app.auth.jwt import get_current_user_required
      from app.models.user import User
      from app.models.report import ReportResponse, ReportCreate
      from app.services.report_service import ReportService
      
      router = APIRouter(prefix="/api", tags=["reports"])
      
      def get_service() -> ReportService:
          """Dependency to get service instance."""
          return ReportService()
      
      @router.get("/reports", response_model=list[ReportResponse])
      async def list_reports(
          limit: int = Query(default=50, ge=1, le=100),
          offset: int = Query(default=0, ge=0),
          status_filter: Optional[str] = Query(default=None),
          current_user: User = Depends(get_current_user_required),
          service: ReportService = Depends(get_service),
      ) -> list[ReportResponse]:
          """List reports for the current user with filtering."""
          return await service.list_reports(
              user_id=current_user.id,
              limit=limit,
              offset=offset,
              status_filter=status_filter,
          )
      
      @router.post(
          "/reports",
          response_model=ReportResponse,
          status_code=status.HTTP_201_CREATED,
      )
      async def create_report(
          data: ReportCreate,
          current_user: User = Depends(get_current_user_required),
          service: ReportService = Depends(get_service),
      ) -> ReportResponse:
          """Create a new report for the current user."""
          return await service.create_report(data, user_id=current_user.id)
      
      @router.get("/reports/{report_id}", response_model=ReportResponse)
      async def get_report(
          report_id: str,
          current_user: User = Depends(get_current_user_required),
          service: ReportService = Depends(get_service),
      ) -> ReportResponse:
          """Get a specific report."""
          report = await service.get_report_by_id(report_id)
          if report is None:
              raise HTTPException(
                  status_code=status.HTTP_404_NOT_FOUND,
                  detail="Report not found",
              )
          if report.user_id != current_user.id:
              raise HTTPException(
                  status_code=status.HTTP_403_FORBIDDEN,
                  detail="Not authorized to access this report",
              )
          return report
